## 基本介绍

### 概念

文件对我们都不陌生，文件是数据源（保存数据的地方）的一种，比如大家常说的word，txt文档，excel文档

### 作用

文件最主要的作用就是保存数据，它既可以保存一个图片，也可以保存视频，声音等...

### 输入流和输出流

1. 流： 数据在数据源（文件）和程序（内存）之间经历的路径
2. 输入流：数据从数据源到程序内存的路径
3. 输出流：数据从程序内存到数据源的路径

### os.file

```bash
os.File封装所有文件的相关操作，File是一个结构体
```

## 打开文件和关闭文件

```go
// 打开文件
func Open(name string) (file *File, err error)

// 关闭文件
func (f *File) Close() error
```

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Println("file")

	// 打开文件
	// 概念说明： file 的语法
	// 1、file 叫 file 对象
	// 2、file 叫 file 指针
	// 3、file 叫 file 文件句柄
	file, err := os.Open("./1.txt")
	if err != nil {
		fmt.Println("open file err", err)
	}
	// 输出文件，file就是一个指针
	fmt.Printf("file=%v", file)
	// 关闭文件
	err = file.Close()
	if err != nil {
		fmt.Println("close file err", err)
	}
}

```

## 读取文件

### 带缓冲的Reader读取文件

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

func main() {
	fmt.Println("file")

	// 打开文件
	// 概念说明： file 的语法
	// 1、file 叫 file 对象
	// 2、file 叫 file 指针
	// 3、file 叫 file 文件句柄
	file, err := os.Open("./1.txt")
	if err != nil {
		fmt.Println("open file err", err)
	}
	// 当函数退出的时，要即使的关闭file
	defer file.Close()

	// 创建一个 *Reader, 是带缓冲的
	/**
	const (
		defaultBufSize = 4096
	)
	*/
	reader := bufio.NewReader(file)
	// 循环读取文件内容
	for {
		str, err := reader.ReadString('\n') // 读到界限符就换行
		fmt.Print(str)
		if err == io.EOF {                  // io.EOF 标识文件的末尾
			break
		}
		
	}
	fmt.Println("\n文件读取结束")

}

```

### 一次性读取文件

使用ioutil 一次性将整个文件读入内存中，这种方式使用于文件不大的情况

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	fmt.Println("file")

	// 使用 ioutil.ReadFile 一次性将文件读取到位
	content, err := ioutil.ReadFile("./1.txt")
	if err != nil {
		fmt.Println("readfile err", err)
	}
	// 把读取到内容显示在终端
	//content =  []uint8%
	fmt.Printf("%v %T", string(content), content)

	// 我们没有显示的open文件，所以我们也不需要显示的close文件
	// 因为，文件的 open 和 close 被封装在 readfile 函数内部啦
}

```

## 写入文件

```go
/*
OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。
*/
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
```

### 方式1[缓冲区]

#### 1、 创建一个新文件，写入5句 hello world

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {

	fmt.Println("方式1")

	file, err := os.OpenFile("./w1.txt", os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		fmt.Println("open file err", err)
		return
	}
	// 及时关闭句柄
	defer file.Close()
	str := "hello world \n"
	// 使用带缓冲的 *Writer
	writer := bufio.NewWriter(file)
	for i := 0; i < 5; i++ {
		writer.WriteString(str)
	}

	// 因为 writer 带缓冲，因为调用WriteString方法时，其实是写入缓冲中的，所以我们需要调用Flush方法，将缓冲中的数据写入文件
	writer.Flush(); // 刷入文件

}

```

#### 2、打开一个存在的文件中，将原来的内容覆盖成新的内容 10 句 "你好，尚硅谷!"

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	//打开一个存在的文件中，将原来的内容覆盖成新的内容 10 句 "你好，尚硅谷!"
	fmt.Println("方式1")

	file, err := os.OpenFile("./w1.txt", os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		fmt.Println("open file err", err)
		return
	}
	// 及时关闭句柄
	defer file.Close()
	str := "hello w2 \n"
	// 使用带缓冲的 *Writer
	writer := bufio.NewWriter(file)
	for i := 0; i < 5; i++ {
		writer.WriteString(str)
	}

	// 因为 writer 带缓冲，因为调用WriteString方法时，其实是写入缓冲中的，所以我们需要调用Flush方法，将缓冲中的数据写入文件
	writer.Flush() // 刷入文件

}

```

#### 3、打开一个存在的文件，在原来的内容追加内容 'ABC! ENGLISH!'

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	//打开一个存在的文件中，将原来的内容覆盖成新的内容 10 句 "你好，尚硅谷!"
	fmt.Println("方式1")

	file, err := os.OpenFile("./w1.txt", os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		fmt.Println("open file err", err)
		return
	}
	// 及时关闭句柄
	defer file.Close()
	str := "append ABC \n"
	// 使用带缓冲的 *Writer
	writer := bufio.NewWriter(file)
	for i := 0; i < 5; i++ {
		writer.WriteString(str)
	}

	// 因为 writer 带缓冲，因为调用WriteString方法时，其实是写入缓冲中的，所以我们需要调用Flush方法，将缓冲中的数据写入文件
	writer.Flush() // 刷入文件

}

```

#### 4、打开一个存在的文件，将原来的内容读出显示在终端，并且追加 5 句"hello,北京!"

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

func main() {
	// 打开一个存在的文件，将原来的内容读出显示在终端，并且追加 5 句"hello,北京!"
	fmt.Println("方式1")

	file, err := os.OpenFile("./w1.txt", os.O_RDWR|os.O_APPEND, 0666)
	if err != nil {
		fmt.Println("open file err", err)
		return
	}
	// 及时关闭句柄
	defer file.Close()

	// 读取内容，显示终端
	reader := bufio.NewReader(file)
	for {
		str, err := reader.ReadString('\n')
		fmt.Print(str)
		if err == io.EOF {
			break
		}
	}

	str := "hello shandong \n"
	// 使用带缓冲的 *Writer
	writer := bufio.NewWriter(file)
	for i := 0; i < 5; i++ {
		writer.WriteString(str)
	}

	// 因为 writer 带缓冲，因为调用WriteString方法时，其实是写入缓冲中的，所以我们需要调用Flush方法，将缓冲中的数据写入文件
	writer.Flush() // 刷入文件

}

```

### 方式2[一次性]

编程一个程序，将一个文件的内容，写入到另外一个文件。注:这两个文件已经存在了. 说明:使用` ioutil.ReadFile / ioutil.WriteFile `完成写文件的任务.

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main() {
	// 编程一个程序，将一个文件的内容，写入到另外一个文件。注:这两个文件已经存在了. 说明:使用 ioutil.ReadFile / ioutil.WriteFile 完成写文件的任务.
	fmt.Println("方式2")

	// 将w1写入w2
	file1Path := "./w1.txt"
	file2Path := "./w2.txt"

	content, err := ioutil.ReadFile(file1Path)
	if err != nil {
		fmt.Println("file open err", err)
		return
	}
	err = ioutil.WriteFile(file2Path, content, 0666)
	if err != nil {
		fmt.Println("file write err", err)
	}

}

```

## 文件或者文件夹是否存在

```go
// Stat返回一个描述name指定的文件对象的FileInfo。如果指定的文件对象是一个符号链接，返回的FileInfo描述该符号链接指向的文件的信息，本函数会尝试跳转该链接。如果出错，返回的错误值为*PathError类型。
func Stat(name string) (fi FileInfo, err error)
```

```go
package main

import (
	"fmt"
	"os"
)

// 路径是否存在
func PathExist(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}

	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}

func main() {
	fmt.Println("stat")
	isExist, err := PathExist("./w1.txt")
	fmt.Println("isExist", isExist)
	fmt.Println("err", err)

}
```

## 文件拷贝

```bash
说明:将一张图片/电影/mp3 拷贝到另外一个文件 e:/abc.jpg io 包 
func Copy(dst Writer, src Reader) (written int64, err error)
注意; Copy 函数是 io 包提供的.
```

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

// 自己编写一个函数，接收两个文件路径 srcFileName dstFileName
func CopyFile(dstFileName string, srcFileName string) (written int64, err error) {
	srcFile, err := os.Open(srcFileName)
	if err != nil {
		fmt.Printf("open file err=%v\n", err)
	}
	defer srcFile.Close()
	// 通过 srcfile ,获取到 Reader
	reader := bufio.NewReader(srcFile)
	//打开 dstFileName
	dstFile, err := os.OpenFile(dstFileName, os.O_WRONLY|os.O_CREATE, 0666)
	if err != nil {
		fmt.Printf("open file err=%v\n", err)
		return
	}
	//通过 dstFile, 获取到 Writer
	writer := bufio.NewWriter(dstFile)
	defer dstFile.Close()
	return io.Copy(writer, reader)
}
func main() {
	fmt.Println("file copy")

	srcFile := "./1.txt"
	dstFile := "./2.txt"
	_, err := CopyFile(dstFile, srcFile)
	if err == nil {
		fmt.Printf("拷贝完成\n")
	} else {
		fmt.Printf("拷贝错误 err=%v\n", err)
	}

}

```



## 统计英文、数字、空格和其他字符的数量

说明:统计一个文件中含有的英文、数字、空格及其它字符数量

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

// 定义一个结构体，用于保存统计结果
type CharCount struct {
	ChCount    int // 记录英文个数
	NumCount   int // 记录数字的个数
	SpaceCount int // 记录空格的个数
	OtherCount int // 记录其它字符的个数
}

func main() {
	fmt.Println("count")
	//思路: 打开一个文件, 创一个 Reader
	//每读取一行，就去统计该行有多少个 英文、数字、空格和其他字符
	//然后将结果保存到一个结构体
	fileName := "./1.txt"
	file, err := os.Open(fileName)
	if err != nil {
		fmt.Printf("open file err=%v\n", err)
		return
	}
	defer file.Close()
	// 定义个 CharCount 实例
	var count CharCount //创建一个 Reader
	reader := bufio.NewReader(file)
	// 开始循环的读取 fileName 的内容
	for {
		str, err := reader.ReadString('\n')
		if err == io.EOF { //读到文件末尾就退出
			break
		}
		fmt.Println("str", str)
		//为了兼容中文字符, 可以将 str 转成 []rune
		//遍历 str ，进行统计
		strs := []rune(str)
		for _, v := range strs {
			switch {
			case v >= 'a' && v <= 'z':
				fallthrough //穿透
			case v >= 'A' && v <= 'Z':
				count.ChCount++
			case v == ' ' || v == '\t':
				count.SpaceCount++
			case v >= '0' && v <= '9':
				count.NumCount++
			default:
				count.OtherCount++
			}
		}
	}
	// 输出统计的结果看看是否正确
	fmt.Printf("字符的个数为=%v 数字的个数为=%v 空格的个数为=%v 其它字符个数=%v", count.ChCount, count.NumCount, count.SpaceCount, count.OtherCount)
}

```









