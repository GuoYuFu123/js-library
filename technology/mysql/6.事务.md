## 6.事务

### 6.1 、什么是事务

重点：<font color='red'>要么都成功，要么都失败</font>

1、SQL执行  A 给 B 转账200，A减少200元  

2、SQL执行， B 收到 A的转账， B增加200元

#### 事务4大原则《ACID原则》

> 原子性、一致性、隔离性（脏读，幻读，不可重复读。。。。）、持久性      

具体参考，网搜数据库acid原则

##### 原子性（Atomicity）

事务的整体是一个不可分割的单位，要么都成功，要么都失败，a给b转账，a扣款，断电了，b没有收到款

##### 一致性（Consistency）

事务前后的数据整体性保持一致，转账前后金额的数据是一致的

##### 持久性（Durability）

事务一旦提交则不可逆，被持久化到数据库，不会被回滚

##### 隔离性（Isolation）

数据的隔离性是多个用户访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，事务之间要相互隔离

> 隔离所导致的一些问题

###### 脏读

一个事务读取了另一个事务未提交的数据，而这个数据是有可能回滚的；

###### 不可重复读

在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的

###### 幻读

事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.

###### 丢失更新

两个事务同时读取同一条记录，A先修改记录，B也修改记录（B是不知道A修改过），B提交数据后B的修改结果覆盖了A的修改结果。

### 数据库的隔离级别

为了避免上述几种事务之间的影响，SQL Server通过设置不同的隔离级别来进行不同程度的避免。因为高的隔离等级意味着更多的锁，从而牺牲性能。所以这个选项开放给了用户根据具体的需求进行设置。不过默认的隔离级别Read Commited符合了多数的实际需求.

| **隔离级别**              | **脏读** | **丢失更新** | **不可重复读** | **幻读** | **并发模型** | **更新冲突检测** |
| ------------------------- | -------- | ------------ | -------------- | -------- | ------------ | ---------------- |
| 未提交读：Read Uncommited | 是       | 是           | 是             | 是       | 悲观         | 否               |
| 已提交读：Read commited   | 否       | 是           | 是             | 是       | 悲观         | 否               |
| 可重复读：Repeatable Read | 否       | 否           | 否             | 是       | 悲观         | 否               |
| 可串行读：Serializable    | 否       | 否           | 否             | 否       | 悲观         | 否               |

**SQL Server隔离事务之间的影响是通过锁来实现的，通过阻塞来阻止上述影响。不同的隔离级别是通过加不同的锁，造成阻塞来实现的，所以会以付出性能作为代价；安全级别越高，处理效率越低；安全级别越低，效率高。**

​    **\*使用方法：\***SET TRANSACTIONISOLATION LEVEL REPEATABLE READ

#### 未提交读

在读数据时不会检查或使用任何锁。因此，在这种隔离级别中可能读取到没有提交的数据。 

#### 已提交读【默认】

只读取提交的数据并等待其他事务释放排他锁。读数据的共享锁在读操作完成后立即释放。已提交读是SQL Server的默认隔离级别。 

#### 可重复读 

像已提交读级别那样读数据，但会保持共享锁直到事务结束。 

####  可串行读

工作方式类似于可重复读。但它不仅会锁定受影响的数据，还会锁定这个范围。这就阻止了新数据插入查询所涉及的范围。



### 6.2、执行事务

```sql
-- mysql 是默认开始事务自动提交的
SET autocommit = 0 /* 关闭 */
SET autocommit = 1 /* 开启 */

-- 手动处理事务
START TRANSACTION -- 标记一个事务的开始，从这个之后的 sql 都在一个事务里

-- 操作的sql
INSERT xxx;
INSERT xxx;

-- 提交，持久化（成功）
COMMIT；

-- 回滚，回到原来的样子（失败）
ROLLBACK；

-- 事务结束
SET autocommit = 1 -- 开启自动提交

-- 了解
SAVEPOINT 保存事务点名 -- 设置一个事务的保存点
ROLLBACK TO 保存事务点名 -- 回滚到保存点
RELEASE SAVEPOINT 保存事务点名 -- 撤销保存点

```

#### 测试：模拟转账

```sql
-- 转账
CREATE DATABASE shop CHARACTER SET utf8 COLLATE utf8_general_ci;
USE shop;

CREATE TABLE `account` (
	`id` int(3) not null auto_increment,
	`name` varchar(30) not null,
	`money`  decimal(9,2) not null, --  第一个参数是总位数，第2个参数为小数点的位数，整数为1参数-2参数
	primary key (`id`)
) engine=innodb default charset=utf8;

INSERT INTO account(`name`, `money`)
VALUES('A',2000.00),('B',10000.00);

SELECT * from `account`;

-- 模拟转账：事务
set autocommit = 0; -- 关闭自动提交 
start TRANSACTION; -- 开启一个事务

UPDATE account set money=money-500 where name='A'; -- a - 500
UPDATE account set money=money+500 where name='B'; -- b + 500

COMMIT; -- 提交事务，就被持久化到数据库啦
ROLLBACK; -- 回滚

set autocommit = 1; -- 回复默认值
```

#### set autocommit=0 和 start transaction区别

##### 相同之处

- set autocommit=0 是显示设置手动提交事务【隐式开启】
- start transaction 是隐式的设置手动提交事务【显示开启】

##### 不同之处

###### start transaction

> To disable autocommit mode implicitly for a single [series](https://so.csdn.net/so/search?q=series&spm=1001.2101.3001.7020) of statements, use the `START TRANSACTION` statement:

**对于 start transaction 去手动提交事务，中间执行了多条 sql 语句后，当执行了 commit之后，手动事务就结束了**

###### set autocommit=0

> If [`autocommit`](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit) mode is disabled within a session with `SET autocommit = 0`, the session always has a transaction open. A [`COMMIT`](https://dev.mysql.com/doc/refman/5.7/en/commit.html) or [`ROLLBACK`](https://dev.mysql.com/doc/refman/5.7/en/commit.html) statement ends the current transaction and a new one starts.

**对于 set autocommit=0 方式设置手动提交事务的，中间执行多条 sql 语句后， 当 执行了 commit 后， 会结束当前事务，并开启新的事务， 所以事务是没有结束的，继续sql更新，是可以rollback的，只有设置 set autocommit=1 才会结束当前这组事务**























